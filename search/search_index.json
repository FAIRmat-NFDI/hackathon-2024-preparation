{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Developing parsers for FAIR computational data storage of spectroscopy simulations using the NOMAD-Simulations package","text":"<p>This documentation page will provide foundational knowledge for creating parser plugins in NOMAD to manage computational data of spectroscopy simulations. We will use the <code>nomad-simulations</code> package to populate our data schema and extend it when needed. The steps are more general and can be used to create any parser plugin, but in here we will use examples specifically related with theoretical spectroscopy simulations.</p>"},{"location":"#hackathon-information","title":"Hackathon information","text":"<p>The structure of this documentation page is as follows:</p> <ol> <li>Understanding the NOMAD-Simulations schema, what are its strengths and weaknesses, as well as learning how to extend it.</li> <li>How to create a parser plugin, importing the data schema from the NOMAD-Simulations package and matching the files to be parsed.</li> </ol> <p>You can find Assignments throughout these documentation pages which will help you understand the main concepts.</p> <p>To help facilitate discussions and provide prolonged assistance beyond the tutorial, we have created a #hackathon-fairspectra-sep2024 event channel in the NOMAD Discord server.</p>"},{"location":"#general-background","title":"General background","text":"<p>NOMAD is an open-source, community-driven data infrastructure, focusing on materials science data. Originally built as a repository for data from DFT calculations, the NOMAD software can automatically extract data from the output of a large variety of simulation codes. </p> <p>The key advantages of the NOMAD-Simulations schema are summed up in FAIRmat's core values:</p> <ul> <li>Findable: a wide selection of the extracted data is indexed in a database, powering a the search with highly customizable queries and modular search parameters.</li> <li>Accessible: the same database specifies clear API and GUI protocols on how retrieve the full data extracted.</li> <li>Interoperable: we have a diverse team of experts who interface with various materials science communities, looking into harmonizing data representations and insights among them. Following the NOMAD standard also opens up the (meta)data to the \"NOMAD apps\" ecosystem. </li> <li>Reproducible: data is not standalone, but has a history, a vision, a workflow behind it. Our schema aims to capture the full context necessary for understanding and even regenerating via metadata.</li> </ul> <p>We have presented and prepared several resources that can be visited after this Hackathon. You can find more information in the Domain-specific NOMAD documentation page. If you want to know more, we also recommend you to check our latest Tutorial 14, the Youtube playlist as well as its documentation page.</p>"},{"location":"extending_schema/","title":"Extending the NOMAD-Simulations schema","text":"<p>As you develop your parser, you may find that the <code>nomad-simulations</code> package does not include some relevant quantities for your particular use case. You can easily extend upon the schema by adding your own custom schema under the <code>schema_packages/</code> directory in your parser plugin. For this, you should utilize and build upon <code>nomad-simulations</code> for consistency and future compatibility or integration. Below is a decision tree which illustrates the schema development process:</p> <p>From this schematic, we can identify 3 distinct uses or extensions of <code>nomad-simulations</code>:</p> <ol> <li>Direct use of existing section definitions (without extension):<ul> <li>See how to use them in Parser Plugins.</li> </ul> </li> <li>Semantic extension of section definitions:<ul> <li>Create sections that re-define the context through inheritance from existing sections. Quantities definitions within the inherited section can be overwritten.</li> <li>Create brand new sections.</li> </ul> </li> <li>Extending section definitions for normalization functionalities:<ul> <li>The section normalization functions (see Extra: The <code>normalize()</code> class function) can be overwritten to leverage certain tasks out of the parsers.</li> </ul> </li> </ol> <p>You can find more information about writing schemas packages in How to write a schema package in the NOMAD documentation.</p> <p>In order to extend the <code>nomad-simulations</code> schema, add the schema packages when generating the plugin template. This will create a sub-folder <code>src/&lt;parser_name&gt;/schema_packages</code> and a Python file <code>schema_package.py</code> in your parser plugin project.</p> <p>In this page, we will learn about extending the current <code>nomad-simulations</code> schema, and more specifically, the <code>AtomsState</code> information. We will use the same <code>PySCF</code> example, <code>glycine.log</code>, as in Parser Plugins. In that mainfile, we are interested on parsing the simulation cell information for each atom, i.e., we are interested on storing the geometrical state information in <code>AtomicCell</code> and in <code>AtomsState</code>. This information appears in <code>glycine.log</code> as: <pre><code>...\n[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom\n[INPUT]  1 O      0.000000000000   0.000000000000   0.117790000000 AA    0.000000000000   0.000000000000   0.222590840213 Bohr   0.0\n[INPUT]  2 H      0.000000000000   0.755453000000  -0.471161000000 AA    0.000000000000   1.427599269981  -0.890365250576 Bohr   0.0\n[INPUT]  3 H      0.000000000000  -0.755453000000  -0.471161000000 AA    0.000000000000  -1.427599269981  -0.890365250576 Bohr   0.0\n...\n</code></pre></p> <p>Here we have to consider that:</p> <ol> <li>we only need to parse one of the units positions,</li> <li>we only need to pass the symbols and the <code>AtomsState.normalize()</code> function will take care of extracting the atomic number of the chemical elements, and</li> <li>the atomic magnetic moment (<code>Magmom</code> colum) is not defined in <code>AtomsState</code>, so we have to extend the schema. Note that even if they are 0.0, it is a good idea to implement the extraction now and the parsing will work for any finite atomic magnetic moment.</li> </ol> <p>For capturing and returning this information, and as each element is a repeating line, we need to add a <code>repeats=True</code> condition into the <code>ParsedQuantity</code>. Our new <code>LogParser</code> will then be: <pre><code>class LogParser(TextParser):\n    def init_quantities(self):\n        self._quantities = [\n            ParsedQuantity(\n                'program_version', r'PySCF *version *([\\d\\.]+)', repeats=False\n            ),\n            ParsedQuantity(\n                'atoms_information',\n                r'\\[INPUT\\] *\\d *([a-zA-Z])+ *([\\d\\.\\-]+) *([\\d\\.\\-]+) *([\\d\\.\\-]+) *([a-zA-Z]+)[\\d\\.\\-\\s]*[a-zA-Z]* *([\\d\\.\\-]+)',\n                repeats=True\n            ),\n        ]\n</code></pre></p> <p>We have added a new <code>ParsedQuantity</code> for the atoms information: chemical element string, the three positions in cartesian coordinates, the unit of the positions, and the value of the magnetic moment. This regex returns a list of lists, in which each element of the list refers to each chemical and their position in the simulated cell. We need to manipulate the data slightly to store the information in a proper format that the schema understands. In order to do things clear, we are going to define in our <code>PySCFParser()</code> class the following variables: <pre><code>class PySCFParser(MatchingParser):\n    def parse(\n        self,\n        mainfile: str,\n        archive: 'EntryArchive',\n        logger: 'BoundLogger',\n        child_archives: dict[str, 'EntryArchive'] = None,\n    ) -&gt; None:\n\n        log_parser = LogParser(mainfile=mainfile, logger=logger)\n\n        simulation = Simulation()\n        program = Program(\n            name='PySCF', version=log_parser.get('program_version')\n        )\n        simulation.program = program\n\n        # Add the `Simulation` activity to the `archive`\n        archive.data = simulation\n\n        # Match the atoms information\n        atoms_information = log_parser.get('atoms_information', [])\n</code></pre></p> <p>Now, we want to:</p> <ol> <li>Import <code>ModelSystem</code>, <code>AtomicCell</code>, and <code>AtomsState</code>.</li> <li>Instantiate <code>ModelSystem</code> and append it to <code>simulation</code>.</li> <li>Instantiate <code>AtomicCell</code> and append it to <code>ModelSystem</code>.</li> <li>Instantiate <code>AtomsState</code> for each atom, populate these sections with the information, and append them to <code>AtomicCell</code>.</li> </ol> <p>This can be done importing  the <code>atoms_information</code> matched list as:</p> <pre><code># other imports here\nfrom nomad.units import ureg\nfrom nomad_simulations.schema_packages.model_system import ModelSystem, AtomicCell\nfrom nomad_simulations.schema_packages.atoms_state import AtomsState\n\n# `configuration` and `LogParser` defined here\n\n\nclass PySCFParser(MatchingParser):\n    def parse(\n        self,\n        mainfile: str,\n        archive: 'EntryArchive',\n        logger: 'BoundLogger',\n        child_archives: dict[str, 'EntryArchive'] = None,\n    ) -&gt; None:\n\n        log_parser = LogParser(mainfile=mainfile, logger=logger)\n\n        simulation = Simulation()\n        program = Program(\n            name='PySCF', version=log_parser.get('program_version')\n        )\n        simulation.program = program\n\n        # Add the `Simulation` activity to the `archive`\n        archive.data = simulation\n\n        # Match the atoms information\n        atoms_information = log_parser.get('atoms_information', [])\n        # Instantiate `ModelSystem` and append it to `simulation`\n        model_system = ModelSystem()\n        simulation.model_system.append(model_system)\n        # Instantiate `AtomicCell` and append it to `ModelSystem`\n        atomic_cell = AtomicCell()\n        model_system.cell.append(atomic_cell)\n        # Instantiate `AtomsState` for each atom, populate these sections with the information, and append them to `AtomicCell`\n        positions = []\n        for atom in atoms_information:\n            try:\n                atom_state = AtomsState(\n                    chemical_symbol=atom[0],\n                )\n                atomic_cell.atoms_state.append(atom_state)\n                position_unit = {\n                    'AA': 'angstrom',\n                    'Bohr': 'bohr',\n                }\n                positions.append(atom[1:4])\n            except Exception:\n                logger.warning('Matching `atoms_information` is missing some information.')\n        atomic_cell.positions = positions * ureg(position_unit[atom[-2]])\n</code></pre> <p>Note that we have to map the strings in the <code>glycine.log</code> file to a format accepted by Pint. This already stores all the information of each atom, except for the magnetic moment. For the version <code>0.0.5</code> of the <code>nomad-simulations</code> package, there is no <code>Quantity</code> defined in <code>AtomsState</code> to store the magnetic moment of each atom. Thus, the solution here would be to follow the diagram above:</p> <p>And realize that we need to extend <code>AtomsState</code> defining a new <code>Quantity</code>, <code>magnetic_moment</code>. In order to do this, we go to <code>src/nomad_parser_pyscf/schema_packages/schema_package.py</code> and change the content to: <pre><code>from nomad.config import config\nfrom nomad.metainfo import Quantity, SchemaPackage\n\nimport nomad_simulations\nimport numpy as np\n\n\nconfiguration = config.get_plugin_entry_point(\n    'nomad_parser_pyscf.schema_packages:schema_package_entry_point'\n)\n\nm_package = SchemaPackage()\n\n\nclass ExtendedAtomsState(nomad_simulations.schema_packages.atoms_state.AtomsState):\n    magnetic_moment = Quantity(\n        type=np.float64,\n        default=0.0,\n        unit='bohr_magneton',\n        description=\"\"\"\n        Magnetic moment of the atom in Bohr magneton units. This quantity is relevant only for spin-polarized calculations.\n        \"\"\"\n    )\n\n\nm_package.__init_metainfo__()\n</code></pre></p> <p>Note that we defined a new class, so in the parser we need to import this instead of the <code>AtomsState</code> defined in <code>nomad-simulations</code>, as well as adding the parsing of the magnetic moment: <pre><code># other imports here\nfrom nomad.units import ureg\nfrom nomad_simulations.schema_packages.model_system import ModelSystem, AtomicCell\n\nfrom nomad_parser_pyscf.schema_packages.schema_package import ExtendedAtomsState\n\n# `configuration` and `LogParser` defined here\n\n\nclass PySCFParser(MatchingParser):\n    def parse(\n        self,\n        mainfile: str,\n        archive: 'EntryArchive',\n        logger: 'BoundLogger',\n        child_archives: dict[str, 'EntryArchive'] = None,\n    ) -&gt; None:\n\n        log_parser = LogParser(mainfile=mainfile, logger=logger)\n\n        simulation = Simulation()\n        program = Program(\n            name='PySCF', version=log_parser.get('program_version')\n        )\n        simulation.program = program\n\n        # Add the `Simulation` activity to the `archive`\n        archive.data = simulation\n\n        # Match the atoms information\n        atoms_information = log_parser.get('atoms_information', [])\n        # Instantiate `ModelSystem` and append it to `simulation`\n        model_system = ModelSystem()\n        simulation.model_system.append(model_system)\n        # Instantiate `AtomicCell` and append it to `ModelSystem`\n        atomic_cell = AtomicCell()\n        model_system.cell.append(atomic_cell)\n        # Instantiate `AtomsState` for each atom, populate these sections with the information, and append them to `AtomicCell`\n        positions = []\n        for atom in atoms_information:\n            try:\n                atom_state = ExtendedAtomsState(\n                    chemical_symbol=atom[0],\n                    magnetic_moment=atom[-1] * ureg('bohr_magneton')\n                )\n                atomic_cell.atoms_state.append(atom_state)\n                position_unit = {\n                    'AA': 'angstrom',\n                    'Bohr': 'bohr',\n                }\n                positions.append(atom[1:4])\n            except Exception:\n                logger.warning('Matching `atoms_information` is missing some information.')\n        atomic_cell.positions = positions * ureg(position_unit[atom[-2]])\n</code></pre></p> <p>You can print out the <code>archive</code> and its sub-sections to check that the information is properly stored.</p>"},{"location":"nomad_simulations/","title":"Working with the NOMAD-Simulations schema plugin","text":"<p>In NOMAD, all the simulation metadata is defined under the <code>Simulation</code> section. You can find its Python schema defined in the <code>nomad-simulations</code> repository. The entry point for the schema is defined in src/nomad_simulations/schema_packages/__init__.py module. This section will appear under the <code>data</code> section for each NOMAD entry. There is also a specialized documentation page in the <code>nomad-simulations</code> repository.</p> <p>The <code>Simulation</code> section inherits from a more abstract section or concept called <code>BaseSimulation</code>, which at the same time inherits from another section, <code>Activity</code>.</p> Inheritance and composition <p>For simplicity, we will identify the is a concept with inheritance of one section into another (e.g., a <code>Simulation</code> is an <code>Activity</code>) and the has a concept with composition of one section under another (e.g., a <code>Simulation</code> has a <code>ModelSystem</code> sub-section). Strictly speaking, this equivalency is not entirely true, as we are loosing it in some cases. But for the purpose of learning the complicated rules of inheritance and composition, we will conceptually maintain this equivalency for educational purposes.</p> <p>A set of base sections derived from the Basic Formal Ontology (BFO) is used as the basis for our section definitions. The previous inheritance allows us to define <code>Simulation</code> at the same level of other activities in Materials Science, e.g., <code>Experiment</code>, <code>Measurement</code>, <code>Analysis</code>. We do this in order to achieve a common vocabulary and data standardization with the experimental community. Using inheritance of a given section, any user can extend the initial purpose of a NOMAD section and use it to store their specific data. The relationship tree from the most abstract sections upon reaching <code>Simulation</code> is thus:</p> <p>Note that the white-headed arrow here indicates inheritance / is a relationship. <code>BaseSimulation</code> contains the general information about the <code>Program</code> used (see Program), as well as general time information about the simulation, e.g., the datetime at which it started (<code>datetime</code> is defined within <code>Activity</code> and is inherited by <code>BaseSimulation</code>) and ended (<code>datetime_end</code>). <code>Simulation</code> contains further information about the specific input and output sections (see below).</p> Notation for the section attributes in the UML diagram <p>Throughout this documentation page we will use UML diagrams to describe our section / class definitions, as well as to include the information abpit their attributes / quantities including their main definitions. The notation is:</p> <pre><code>&lt;name-of-quantity&gt;: &lt;type-of-quantity&gt;, &lt;(optional) units-of-quantity&gt;\n</code></pre> <p>Thus, <code>cpu1_start: np.float64, s</code> means that there is a quantity named <code>'cpu1_start'</code> of type <code>numpy.float64</code> and whose units are <code>'s'</code> (seconds). We also include the existence of sub-sections by bolding the name. For example, there is a sub-section under <code>Simulation</code> named <code>'model_method'</code> whose section defintion can be found in the <code>ModelMethod</code> section. We will represent this sub-section containment in more complex UML diagrams in the future using the containment arrow (see below for the specific ase of <code>Program</code>).</p> <p>We use double inheritance from <code>EntryData</code> in order to populate the <code>data</code> section in the NOMAD archive. All of the base sections discussed here are subject to the public normalize function in NOMAD. The function <code>set_system_branch_depth()</code> is related with the ModelSystem section.</p>"},{"location":"nomad_simulations/#initial-steps","title":"Initial steps","text":"<p>Let's use this knowledge to see how to work with the schema in practice. In order to do that, we need to install the <code>nomad-simulations</code> package. First, create the directory and the virtual environment in the terminal. You can use Python 3.9, 3.10, or 3.11:</p> <pre><code>mkdir test_nomadsimulations\ncd test_nomadsimulations/\npython3.11 -m venv .pyenv\nsource .pyenv/bin/activate\n</code></pre> <p>Once this is done, install the <code>nomad-simulations</code> package: <pre><code>pip install --upgrade pip\npip install nomad-simulations \n</code></pre></p> Version installation issue <p>If you are having versioning problems when doing <code>pip install nomad-simulations</code>, we recommend you to try: <pre><code>pip install nomad-simulations --index-url https://gitlab.mpcdf.mpg.de/api/v4/projects/2187/packages/pypi/simple\n</code></pre></p> <p>The flag <code>--index-url</code> points to an internal package registry for installing the NOMAD package within the <code>nomad-simulations</code> one. If the problem persists, feel free to contact us.</p> <p>Assignment 2.1</p> <p>Create an instance of the <code>Simulation</code> section. Imagine you know that the CPU1 took 24 minutes and 30 seconds on finishing the simulation; can you populate the <code>Simulation</code> section with these times? What is the elapsed time in seconds? And in hours?</p> Solution 2.1 <p>We can open a Python console: <pre><code>python\n</code></pre></p> <p>And import and instantiate the <code>Simulation</code> section: <pre><code>from nomad_simulations.schema_packages.general import Simulation\nsimulation = Simulation()\n</code></pre></p> <p>Now, we can assign the elapsed time of the CPU1 by defining the start and the end quantities, i.e., <code>cpu1_start</code> and <code>cpu1_end</code>. To assign the units, we also need to import the Pint utility class <code>ureg</code>: <pre><code>from nomad.units import ureg\nsimulation.cpu1_start = 0 * ureg.second\nsimulation.cpu1_end = 30 * ureg.second + 24 * ureg.minute\n</code></pre></p> <p>In seconds, the elapsed time can be printed by doing: <pre><code>simulation.cpu1_end - simulation.cpu1_start\n</code></pre> which is 1470 seconds. In hours, we can use the method <code>to('hour')</code>: <pre><code>(simulation.cpu1_end - simulation.cpu1_start).to('hour')\n</code></pre> which give us approximately 0.4083 hours.</p>"},{"location":"nomad_simulations/#sub-sections-in-simulation","title":"Main sub-sections in <code>Simulation</code>","text":"<p>The <code>Simulation</code> section is composed of 4 main sub-sections:</p> <ol> <li><code>Program</code>: contains all the program metadata, e.g., <code>name</code> of the program, <code>version</code>, etc.</li> <li><code>ModelSystem</code>: contains all the system metadata about geometrical positions of atoms, their states, simulation cells, symmetry information, etc.</li> <li><code>ModelMethod</code>: contains all the methodological metadata, and is divided in two main aspects: the mathematical model or approximation used in the simulation (e.g., <code>DFT</code>, <code>GW</code>, <code>ForceFields</code>, etc.) and the numerical settings used to compute the properties (e.g., meshes, self-consistent parameters, basis sets settings, etc.).</li> <li><code>Outputs</code>: contains all the output properties obtained during the simulation.</li> </ol> <p>Self-consistent steps, SinglePoint entries, and more complex workflows.</p> <p>The minimal unit for storing data in the NOMAD archive is an entry. In the context of simulation data, an entry may contain data from a calculation on an individual system configuration (e.g., a single-point DFT calculation) using only the above-mentioned sections of the <code>Simulation</code> section. Information from self-consistent iterations to converge properties for this configuration are also contained within these sections.</p> <p>More complex calculations that involve multiple configurations require the definition of a workflow section within the archive. Depending on the situation, the information from individual workflow steps may be stored within a single or multiple entries. For example, for efficiency, the data from workflows involving a large amount of configurations, e.g., molecular dynamics trajectories, are stored within a single entry. Other standard workflows store the single-point data in separate entries, e.g.,  a <code>GW</code> calculation is composed of a <code>DFT SinglePoint</code> entry and a <code>GW SinglePoint</code> entry. Higher-level workflows, which simply connect a series of standard or custom workflows, are typically stored as a separate entry. See Tutorial 14: Part V - Custom Workflows for more information.</p> <p>The following schematic represents a simplified representation of the <code>Simulation</code> section (note that the arrows here are a simple way of visually defining inputs and outputs):</p>"},{"location":"nomad_simulations/#program","title":"<code>Program</code>","text":"<p>The <code>Program</code> section contains all the information about the program / software / code used to perform the simulation. The detailed relationship tree is:</p> <p>Note that the rhombo-headed arrow here indicates a composition / has a relationship, so that <code>BaseSimulation</code> has a <code>Program</code> sub-section under it.</p> <p>Assignment 2.2</p> <p>Instantiate a <code>Program</code> section and directly assign the name <code>'VASP'</code> and the version <code>'5.0.0'</code> quantities. Add this sub-section to the <code>Simulation</code> section created in the Assignment 2.1. Can you re-assign the <code>Program.version</code> quantity to be an integer number, 5?</p> Solution 2.2 <p>We can import and assign directly quantities of sections by doing: <pre><code>from nomad_simulations.schema_packages.general import Program\nprogram = Program(name='VASP', version='5.0.0')\n</code></pre></p> <p>And we can add it as a sub-section of <code>Simulation</code> by assigning the attribute of that class: <pre><code>simulation.program = program\n</code></pre></p> <p>If we try to re-assign: <pre><code>program.version = 5\n</code></pre> the code will complain with a <code>TypeError</code>: <pre><code>TypeError: The value 5 with type &lt;class 'int'&gt; for quantity nomad_simulations.schema_packages.general.Program.version:Quantity is not of type &lt;class 'str'&gt;\n</code></pre> This is because in the defintion of the <code>class Program</code> and the <code>Quantity:version</code>, we defined the type to be a string. So answering the question: no, it is not possible to re-assign <code>version</code> to be an integer due to the fact that is defined to be a string.</p>"},{"location":"nomad_simulations/#modelmethod","title":"<code>ModelMethod</code>","text":"<p>The <code>ModelMethod</code> section is an input section which contains all the information about the mathematical model used to perform the simulation. <code>ModelMethod</code> also contains a specialized sub-section called <code>NumericalSettings</code>. The detailed relationship tree is:</p> <p><code>ModelMethod</code> is thus a sub-section under <code>Simulation</code>. It inherits from an abstract section <code>BaseModelMethod</code>, as well as containing a sub-section called <code>contributions</code> of the same section. The underlying idea of <code>ModelMethod</code> is to parse the input parameters of the mathematical model, typically a Hamiltonian. This total Hamiltonian or model could be split into individual sub-terms or <code>contributions</code>. Each of the electronic-structure methodologies inherit from <code>ModelMethodElectronic</code>, which contains a boolean <code>is_spin_polarized</code> indicating if the <code>Simulation</code> is spin polarized or not. The different levels of abstractions are useful when dealing with commonalities amongst the methods.</p> <p>Assignment 2.3</p> <p>Instantiate a <code>DFT</code> section. For simplicity, you can also assign the <code>jacobs_ladder</code> quantity to be <code>'LDA'</code>. Add this sub-section to the <code>Simulation</code> section created in the Assignment 2.1. What is the underlying concept that allows you to add directly the <code>class DFT</code> under <code>Simulation.model_method</code>, provided that the definition of this attribute is a <code>ModelMethod</code> sub-section? Can you reason why the version 0.0.2 of the <code>nomad-simulations</code> schema is inconsistent in handling the <code>xc_functionals</code> contributions?</p> Solution 2.3 <p>Similarly to Assignment 2.2, we can import and create the <code>DFT</code> section: <pre><code>from nomad_simulations.schema_packages.model_method import DFT\ndft = DFT(jacobs_ladder='LDA')\n</code></pre></p> <p>This time, due to the fact that <code>Simulation.model_method</code> is a repeating sub-section (i.e., a list of sub-sections), we need to append <code>dft</code> instead of directly assigning the attribute: <pre><code>simulation.model_method.append(dft)\n</code></pre></p> <p>Thanks to inheritance of <code>class DFT</code> with <code>ModelMethod</code> and polymorphism, we can directly append <code>dft</code> as a <code>model_method</code> sub-section.</p> <p>The current schema is also a bit inconsistent due to the fact that <code>BaseModelMethod</code> has a sub-section called <code>contributions</code>, while <code>DFT</code> has also a sub-section called <code>xc_functionals</code>, hence both sub-sections live at the same time under the section <code>DFT</code>. Conceptually, both sub-sections are the same: they refer to a sub-term or contribution of the total DFT Hamiltonian, thus, their definitions should be combined, and only one sub-section should be used. The best action here would be to open an issue in the <code>nomad-simulations</code> Github repository, or directly contact the maintainers.</p>"},{"location":"nomad_simulations/#numericalsettings","title":"<code>NumericalSettings</code>","text":"<p>The <code>NumericalSettings</code> section is an abstract section used to define the numerical parameters set during the simulation, e.g., the plane-wave basis cutoff used, the k-mesh, etc. These parameters can be defined into specialized classes which inherit from <code>NumericalSettings</code> (similar to what happens with all the electronic-structure methodologies and <code>ModelMethod</code>). The detailed relationship tree is:</p> <p>Assignment 2.4</p> <p>Instantiate a <code>SelfConsistency</code> section and assign the quantity <code>threshold_change</code> to be <code>1e-3</code> and the <code>threshold_change_unit</code> to be <code>'joule'</code>. Add this sub-section to the <code>DFT</code> section created in the Assignment 2.3. Is the new information also stored in the <code>Simulation</code> section created in Assignment 2.1? Can you access the information of the Jacobs ladder string used in this simulation starting from the newly instantiated class?</p> Solution 2.4 <p>We can import and create the class <code>SelfConsistency</code>, assign the specified quantities, and append it under <code>dft</code>: <pre><code>from nomad_simulations.schema_packages.numerical_settings import SelfConsistency\nscf = SelfConsistency(threshold_change=1e-3, threshold_change_unit='joule')\ndft.numerical_settings.append(scf)\n</code></pre></p> <p>In order to see if <code>scf</code> is showing directly under <code>simulation</code>, we can: <pre><code>simulation.model_method[0].numerical_settings\n</code></pre> which indeed returns: <pre><code>[SelfConsistency:SelfConsistency(name, threshold_change, threshold_change_unit)]\n</code></pre></p> <p>In order to go from <code>scf</code> to the <code>dft.jacobs_ladder</code> information, we need to go one level up with respect to <code>scf</code>. In order to do this, we can use the property <code>m_parent</code>: <pre><code>scf.m_parent.jacobs_ladder\n</code></pre> which will return: <pre><code>'LDA'\n</code></pre></p>"},{"location":"nomad_simulations/#modelsystem","title":"<code>ModelSystem</code>","text":"<p>The <code>ModelSystem</code> section is an input section which contains all the information about the geometrical space quantities (positions, lattice vectors, volumes, etc) of the simulated system. This section contains various quantities and sub-sections which aim to describe the system in the most complete way and in a variety of cases, from unit cells of crystals and molecules up to microstructures. In order to handle this hierarchical structure, <code>ModelSystem</code> is nested over itself, i.e., a <code>ModelSystem</code> can be composed of sub-systems, which at the same time could be composed of smaller sub-systems, and so on. This is done thanks to the (proxy) sub-section attribute called <code>model_system</code>.</p> <p>The <code>Cell</code> sub-section is an important section which contains information of the simulated cell, including the <code>lattice_vectors</code> and the <code>positions</code> of the particles within. However, it does not contain specific information about these particles, e.g., their chemical identity or electronic state, as this is the responsibility of a more specialized section, the <code>AtomicCell</code>. This section stores the relevant information about each of the atoms constituting the material via the <code>AtomsState</code> sub-section. The <code>Symmetry</code> sub-section contains standard symmetry classifications of the system, while the <code>ChemicalFormula</code> sub-section stores various strings that allow the system to be identified in a specific format of the chemical formulas (IUPAC, Hill, etc).</p> <p>The detailed relationship tree is:</p> <p>The <code>Entity</code> abstract section is defined in the Basic Formal Ontology (BFO) similar to <code>Activity</code>, and we use it to abstract our <code>ModelSystem</code>. In fact, <code>ModelSystem</code> is inheriting from an intermediate abstract section called <code>System</code>. This base section, <code>System</code>, is also used by the experimental data models to define the composition and structure of the measured materials.</p> GeometricSpace and simulated cells. <p>The abstract section <code>GeometricSpace</code> is used to define more general real space quantities related with the system of reference used, areas, lengths, volumes, etc. However, this section and <code>Cell</code> are currently (version 0.0.3) under revision and will probably change in the near future.</p>"},{"location":"nomad_simulations/#atomsstate","title":"<code>AtomsState</code> and other sub-sections","text":"<p>The <code>AtomsState</code> section is a list of sub-sections within <code>AtomicCell</code>, corresponding to the list of particles specified by the <code>positions</code> array defined under <code>Cell</code>. Each <code>AtomsState</code> section contains information about a specific chemical element used in the simulation, and may also contain additional <code>OrbitalsState</code>, <code>CoreHole</code>, or <code>HubbardInteractions</code> information. The detailed relationship tree is:</p> <p>Assignment 2.5</p> <p>Instantiate two <code>AtomsState</code> sections and assign the <code>chemical_symbol</code> to be <code>'Ga'</code> and <code>'As'</code> for each of these sections. For this assignment, we also need to define a <code>logger</code> object in order for the functionalities to work: <pre><code>from nomad import utils\nlogger = utils.get_logger(__name__)\n</code></pre> Using a method of <code>AtomsState</code>, what is the atomic number of Ga and of As?</p> Solution 2.5 <p>We can import and create two instances of <code>AtomsState</code> and assign <code>chemical_symbol</code> in a variety of ways. In this case, we used list comprehension: <pre><code>from nomad_simulations.schema_packages.atoms_state import AtomsState\natoms_states = [AtomsState(chemical_symbol=element) for element in ['Ga', 'As']]\n</code></pre></p> <p>For each of the atoms, we can use the class method <code>resolve_atomic_number(logger)</code> which will directly return the atomic number of each section: <pre><code>[atom.resolve_atomic_number(logger=logger) for atom in atoms_states]\n</code></pre> which returns: <pre><code>[31, 33]\n</code></pre> Hence, the atomic number of Ga is 31 and of As is 33.</p> <p>Assignment 2.6</p> <p>Instantiate a <code>ModelSystem</code> section and a <code>AtomicCell</code> section. Assign the <code>positions</code> in the <code>AtomicCell</code> section to be <code>[[0, 0, 0], [1, 1, 1]]</code> in meters. Add the <code>atoms_states</code> defined in the Assignment 2.5 under the <code>AtomicCell</code> section. Append this <code>AtomicCell</code> section under <code>ModelSystem</code>, and append <code>ModelSystem</code> to the <code>Simulation</code> section created in Assignment 2.1.</p> <p>Now, we want to extract the different formats in which the chemical formulas of this system can be written. For that, instantiate directly the <code>ChemicalFormula</code> sub-section under <code>ModelSystem</code>. Note: you can use the <code>ChemicalFormula.normalize(archive, logger)</code> method, and pass <code>archive=None</code> to this function.</p> <p>What are the different formats of the chemical formula? What is the string of the <code>descriptive</code> format and why it coincides with other format(s) in the sub-section?</p> Solution 2.6 <p>We can import and create instances of <code>ModelSystem</code> and <code>AtomicCell</code> and assign the corresponding quantities directly: <pre><code>from nomad_simulations.schema_packages.model_system import ModelSystem, AtomicCell\nmodel_system = ModelSystem()\natomic_cell = AtomicCell(atoms_state=atoms_states, positions=[[0, 0, 0], [1, 1, 1]] * ureg.meter)\nmodel_system.cell.append(atomic_cell)\n</code></pre></p> <p>We can append this section to <code>Simulation</code>: <pre><code>simulation.model_system.append(model_system)\n</code></pre></p> <p>We can now assign directly an empty <code>ChemicalFormula</code> section to <code>ModelSystem</code>, in order to be able to call for the specific class method: <pre><code>from nomad_simulations.schema_packages.model_system import ChemicalFormula\nmodel_system.chemical_formula = ChemicalFormula()\n</code></pre></p> <p>In order to extract the formulas and assign them to the quantities of the section <code>ChemicalFormula</code>, we can use the method <code>normalize()</code>. This class method takes two arguments as inputs: <code>archive</code> and <code>logger</code>. For the purpose of this tutorial, we can set <code>archive=None</code>: <pre><code>model_system.chemical_formula.normalize(archive=None, logger=logger)\n</code></pre></p> <p>Now, the <code>ChemicalFormula</code> sub-section contains the information of the different formats for the chemical formula: <code>reduced</code> and <code>hill</code> are both <code>'AsGa'</code>, while <code>iupac</code> is <code>'GaAs'</code>. The <code>descriptive</code> formula is set depending on the chemical elements present in the system, and because neither <code>'H'</code> nor <code>'O'</code> is present (i.e., no organic formulas), and gallium arsenide does not belong to any format exceptions, then it is set to the inorganic typical formula <code>'GaAs'</code>, coinciding with <code>iupac</code>. The <code>anonymous</code> formula is <code>'AB'</code>.</p>"},{"location":"nomad_simulations/#outputs","title":"<code>Outputs</code>","text":"<p>The <code>Outputs</code> section contains all the information about the properties computed by the simulations, as well as references to the relevant <code>ModelMethod</code> and <code>ModelSystem</code>. Each property is stored individually under <code>Outputs</code>, and inherits from an abstract section call <code>PhysicalProperty</code>. The <code>PhysicalProperty</code> base section contains the <code>value</code> of the property along with other relevant quantities. The <code>variables</code> sub-section enables the physical property to be stored as a function of a varying parameter. Accordingly, the shape of value is calculated in a dynamic way. This means that the same physical property (e.g., <code>ElectronicBandGap</code>) could have different shapes depending on the use-case being parsed (e.g., a single scalar number or a set of varying scalars with respect to a variable, e.g., <code>Temperature</code>).</p> <p>The <code>Outputs</code> section can be further specialized into <code>SCFOutputs</code> in case the properties are calculated in a series of self-consistent steps. The steps are stored under a sub-section called <code>scf_steps</code>, while the last step and other non-self-consistently calculated properties are stored directly under <code>SCFOutputs</code>. The reference to the <code>SelfConsistency</code> section (see NumericalSettings) allows us to automatically determine if a self-consistently calculated property is converged or not.</p> <p>The detailed relationship tree is:</p> <p>Assignment 2.7</p> <p>Instantiate an <code>SCFOutputs</code> section. We are going to store a self-consistently calculated <code>FermiLevel</code>, whose values at each step are <code>[1, 1.5, 2, 2.1, 2.101]</code> in eV. Add the appropiate references to the <code>ModelMethod</code> and <code>ModelSystem</code> sections created in Assignment 2.3 and Assignment 2.6, respectively. For the self-consistently calculated <code>FermiLevel</code> section, add the reference to the section <code>SelfConsistency</code> created in Assignment 2.4.</p> <p>Check if the <code>FermiLevel</code> is self-consistently converged or not by using a class method from <code>SCFOutputs</code>. What happens if the <code>SelfConsistency.threshold_change</code> is now <code>1e-24</code>?</p> Solution 2.7 <p>We can import and create an instance of <code>SCFOutputs</code> and append it to simulation: <pre><code>from nomad_simulations.schema_packages.outputs import SCFOutputs\nscf_outputs = SCFOutputs()\nsimulation.outputs.append(scf_outputs)\n</code></pre></p> <p>We can add the references to the other <code>ModelMethod</code> and <code>ModelSystem</code> sections by doing: <pre><code>scf_outputs.model_method_ref = simulation.model_method[0]\nscf_outputs.model_system_ref = simulation.model_system[0]\n</code></pre></p> <p>Now, we need to create the <code>scf_steps</code> sub-sections with the information of the <code>FermiLevel</code> steps and their values. For that, <pre><code>from nomad_simulations.schema_packages.outputs import Outputs\nfrom nomad_simulations.schema_packages.properties import FermiLevel\nfor value in [1, 1.5, 2, 2.1, 2.101]:\n    fermi_level = FermiLevel()\n    fermi_level.value = value * ureg.eV\n    scf_outputs.scf_steps.append(Outputs(fermi_levels=[fermi_level]))\n</code></pre> Note that:</p> <ol> <li>The properties like <code>fermi_levels</code> are repeated sub-sections under <code>Outputs</code>, so we need to assign a list.</li> <li>The <code>scf_steps</code> sub-sections are <code>Outputs</code>, hence we need to import the <code>Outputs</code> section and append it to that attribute.</li> </ol> <p>We also need to add the last step directly under <code>scf_outputs</code> and add the reference to the <code>SelfConsistency</code> section: <pre><code>scf_outputs.fermi_levels.append(FermiLevel(value=2.101 * ureg.eV, self_consistency_ref=simulation.model_method[0].numerical_settings[0]))\n</code></pre></p> <p>In order to check if the <code>FermiLevel</code> is converged or not, we can use the class method <code>resolve_is_scf_converged()</code>. This method has various inputs that are explained in the method itself. Here we will simply use the function like: <pre><code>scf_outputs.resolve_is_scf_converged(property_name='fermi_levels', i_property=0, physical_property=scf_outputs.fermi_levels[0], logger=logger)\n</code></pre> which indeed returns <pre><code>True\n</code></pre> So the <code>FermiLevel</code> is converged.</p> <p>Now, if we set: <pre><code>scf.threshold_change = 1e-24\n</code></pre> And re-run the <code>resolve_is_scf_converged()</code> line from above, we can see that the <code>FermiLevel</code> is not self-consistenly converged: <pre><code>False\n</code></pre></p> <p>The reason for this is that, in joules, the last two self-consistent steps (where the Fermi level is 2.1 and 2.101 eV) have a difference which can be also computed with another class method: <pre><code>scf_values = scf_outputs.get_last_scf_steps_value(scf_last_steps=scf_outputs.scf_steps[-2:], property_name='fermi_levels', i_property=0, scf_parameters=scf, logger=logger)\nabs(scf_values[0] - scf_values[1])\n</code></pre> which returns: <pre><code>1.6021766340002688e-22\n</code></pre> Then, a <code>threshold_change</code> of <code>1e-24</code> is smaller than the difference, so that the <code>FermiLevel</code> is not converged.</p> <p>Assignment 2.8</p> <p>We are going to store two <code>ElectronicBandGap</code> property sections under the <code>SCFOutputs</code> section created in the Assignment 2.7:</p> <ul> <li>An <code>ElectronicBandGap</code> whose value is 2 eV.</li> <li>An <code>ElectronicBandGap</code> varying with <code>Temperature</code>, whose values are <code>[1, 1.5, 2]</code> in eV for <code>[100, 150, 200]</code> temperatures in Kelvin.</li> </ul> <p>In the second situation of an electronic band gap which varies with the <code>Temperature</code>, what happens if you directly assign <code>value</code> before defining the <code>Temperature</code> variables sub-section in <code>ElectronicBandGap</code>?</p> Solution 2.8 <p>We can import the <code>ElectronicBandGap</code> property and assign the first case of an electronic band gap which is 2 eV: <pre><code>from nomad_simulations.schema_packages.properties import ElectronicBandGap\nband_gap = ElectronicBandGap()\nband_gap.value = 2 * ureg.eV\nscf_outputs.electronic_band_gaps.append(band_gap)\n</code></pre></p> <p>We can do the same for the temperature-dependent band gap by importing and defining the <code>Temperature</code> variable sub-section (note that <code>variables</code> is a repeated sub-section, thus we need to assign a list): <pre><code>from nomad_simulations.schema_packages.variables import Temperature\nband_gap_T = ElectronicBandGap(variables=[Temperature(points=[100, 150, 200] * ureg.kelvin)])\nband_gap_T.value = [1, 1.5, 2] * ureg.eV\nscf_outputs.electronic_band_gaps.append(band_gap_T)\n</code></pre></p> <p>Here, we have assigned first <code>variables</code> before the <code>value</code> of the property. However, if we want to assign first the <code>value</code>: <pre><code>band_gap_T = ElectronicBandGap()\nband_gap_T.value = [1, 1.5, 2] * ureg.eV\n</code></pre> we will get a <code>ValueError</code> due to the fact that <code>variables</code> is not set and the shape of <code>value</code> is not empty: <pre><code>ValueError: The shape of the stored `value` [3] does not match the full shape [] extracted from the variables `n_points` and the `shape` defined in `PhysicalProperty`.\n</code></pre></p> <p>Thus, the <code>variables</code> sub-sections must be set before setting the <code>value</code> of a physical property. This is because the <code>class PhysicalProperty</code> is doing validations on the shape of the <code>variables</code> and <code>value</code>, and it only works if <code>variables</code> is set first. Only when the shape of <code>value</code> is empty and due to the fact that <code>variables</code> is set by default to an empty list, then we would not get any error.</p>"},{"location":"nomad_simulations/#normalize-function","title":"Extra: The <code>normalize()</code> class function","text":"<p>Each base section defined using the NOMAD schema has a set of public functions which can be used at any moment when reading and parsing files in NOMAD. The <code>normalize(archive, logger)</code> function is a special case of such functions, which warrants an in-depth description.</p> <p>This function is run within the NOMAD infrastructure by the <code>MetainfoNormalizer</code> in the following order:</p> <ol> <li>A child section's <code>normalize()</code> function is run before its parents' <code>normalize()</code> function.</li> <li>For sibling sections, the <code>normalize()</code> function is executed from the smaller to the larger <code>normalizer_level</code> attribute. If <code>normalizer_level</code> is not set or if they are the same for two different sections, the order is established by the attributes definition order in the parent section.</li> <li>Using <code>super().normalize(archive, logger)</code> runs the inherited section normalize function.</li> </ol> <p>Let's see some examples. Imagine having the following <code>Section</code> and <code>SubSection</code> structure:</p> <pre><code>from nomad.datamodel.data import ArchiveSection\n\n\nclass Section1(ArchiveSection):\n    normalizer_level = 1\n\n    def normalize(self, archive, logger):\n        # some operations here\n        pass\n\n\nclass Section2(ArchiveSection):\n    normalizer_level = 0\n\n    def normalize(self, archive, logger):\n        super().normalize(archive, logger)\n        # Some operations here or before `super().normalize(archive, logger)`\n\n\nclass ParentSection(ArchiveSection):\n\n    sub_section_1 = SubSection(sub_section=Section1.m_def, repeats=False)\n\n    sub_section_2 = SubSection(sub_section=Section2.m_def, repeats=True)\n\n    def normalize(self, archive, logger):\n        super().normalize(archive, logger)\n        # Some operations here or before `super().normalize(archive, logger)`\n</code></pre> <p>Now, <code>MetainfoNormalizer</code> will be run on the <code>ParentSection</code>. Applying rule 1, the <code>normalize()</code> functions of the <code>ParentSection</code>'s childs are executed first. The order of these functions is established by rule 2 with the <code>normalizer_level</code> atrribute, i.e., all the <code>Section2</code> (note that <code>sub_section_2</code> is a list of sections) <code>normalize()</code> functions are run first, then <code>Section1.normalize()</code>. Then, the order of execution will be:</p> <ol> <li><code>Section2.normalize()</code></li> <li><code>Section1.normalize()</code></li> <li><code>ParentSection.normalize()</code></li> </ol> <p>In case we do not assign a value to <code>Section1.normalizer_level</code> and <code>Section2.normalizer_level</code>, <code>Section1.normalize()</code> will run first before <code>Section2.normalize()</code>, due to the order of <code>SubSection</code> attributes in <code>ParentSection</code>. Thus the order will be in this case:</p> <ol> <li><code>Section1.normalize()</code></li> <li><code>Section2.normalize()</code></li> <li><code>ParentSection.normalize()</code></li> </ol> <p>By checking on the <code>normalize()</code> functions and rule 3, we can establish whether <code>ArchiveSection.normalize()</code> will be run or not. In <code>Section1.normalize()</code>, it will not, while in the other sections, <code>Section2</code> and <code>ParentSection</code>, it will.</p>"},{"location":"parser_plugins/","title":"Creating parser plugins","text":"<p>The role of a parser is to map between a structure or unstructure file into a well-defined, standardized, and (ideally) FAIR data schema. In our case, we are interested on mapping simulation data into the <code>nomad-simulations</code> schema. When the sections defined in <code>nomad-simulations</code> are not enough, any user can extend and tune the schema to their specific needs, see Extending the schema.</p> <p>In NOMAD, when an user creates an upload and push some files, a processing occurs. This processing involves several steps, being matching and parsing the most important and relevant ones:</p> <ol> <li>Matching the file(s) to the relevant parser class called <code>&lt;ParserName&gt;Parser</code>. Only a specific file is matched with the parser class, which receives the name of mainfile. </li> <li>Call into the <code>&lt;ParserName&gt;Parser</code> class function <code>parse()</code>. </li> <li>The <code>parse()</code> function populates the archive from the mainfile and other auxiliary files which might be relevant. This archive contains of the relevant metadata in a NOMAD entry.</li> </ol> <p>You can find more information about processing the NOMAD documentation page, see Explanation - Processing. Schematically, this processing can be visualized as:</p> <p>In this page, we are going to learn how to create a parser, its structure and basic functionalities. NOMAD parsers are plugins, and thus can be defined in their own repositories and be developed independently of the main software. In case of administrating a NOMAD Oasis, you can read more about connecting plugins in the NOMAD documentation, see NOMAD Oasis - Install plugins.</p>"},{"location":"parser_plugins/#start-plugin","title":"Starting a plugin project","text":"<p>To create your own parser plugin, visit the NOMAD plugin template and click the \u201cUse this template\u201d button (you need a Github account to do so):</p> <p>You can decide where to host the parser plugin. Once this is done, in your local machine you can clone the generated repository. For the purpose of this example, we will use JosePizarro3/example-plugin: <pre><code>git clone https://github.com/JosePizarro3/example-plugin.git\n</code></pre></p> <p>All the steps we are going to do can be found in the branch <code>pyscf-new-template</code>.</p> <p>Go to the <code>example-plugin</code> directory and create a virtual environment with Python 3.9, 3.10, or 3.11, and activate it: <pre><code>cd example-plugin\npython3.11 -m venv .pyenv\n. .pyenv/bin/activate\n</code></pre></p> <p>Install <code>uv</code> (a very fast installer of Python packages) and <code>cruft</code>, and follow the instructions in the <code>README.md</code> to generate the parser: <pre><code>pip install --upgrade pip\npip install uv cruft\ncruft create https://github.com/FAIRmat-NFDI/cookiecutter-nomad-plugin\n</code></pre></p> <p>You will be prompted with some questions and information regarding the plugin. Make sure to include both <code>parser</code> and <code>schema_package</code> options (the latter will be use in the Extending the Schema part): <pre><code>  [1/13] full_name (John Doe): &lt;whatever-name&gt;\n  [2/13] email (john.doe@physik.hu-berlin.de): &lt;whatever-email&gt; \n  [3/13] github_username (Github organization or profile name, default: foo): &lt;whatever-github-name&gt;\n  [4/13] plugin_name (foobar): nomad-parser-pyscf    \n  [5/13] module_name (recommended: press enter to use the default module name) \n(nomad_parser_pyscf):     \n  [6/13] short_description (Nomad example template): NOMAD parser plugin for PySCF simulations output in a log text file. \n  [7/13] version (0.1.0): \n  [8/13] Select license\n    1 - MIT\n    2 - BSD-3\n    3 - GNU GPL v3.0+\n    4 - Apache Software License 2.0\n    Choose from [1/2/3/4] (1): &lt;whatever-license&gt;\n  [9/13] include_schema_package [y/n] (y): y\n  [10/13] include_normalizer [y/n] (y): n\n  [11/13] include_parser [y/n] (y): y\n  [12/13] include_app [y/n] (y): n\n  [13/13] include_example_uploads [y/n] (y): n\n</code></pre></p> <p>You can use the script under the generated folder to move all files one level up: <pre><code>sh nomad-parser-pyscf/move_template_files.sh\n</code></pre></p> <p>The structure of the plugin is (without including the <code>docs</code> and <code>mkdocs.yml</code> files): <pre><code>example-plugin/\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 LICENSE\n\u251c\u2500\u2500 pyproject.toml\n\u251c\u2500\u2500 src/\n\u2502   \u2514\u2500\u2500 nomad_parser_pyscf/\n\u2502       \u251c\u2500\u2500 __init__.py\n\u2502       \u251c\u2500\u2500 parsers/\n\u2502       \u2502   \u251c\u2500\u2500 __init__.py\n\u2502       \u2502   \u2514\u2500\u2500 parser.py\n\u2502       \u2514\u2500\u2500 schema_packages/\n\u2502           \u251c\u2500\u2500 __init__.py\n\u2502           \u2514\u2500\u2500 schema_package.py\n\u251c\u2500\u2500 tests/\n\u2502   \u251c\u2500\u2500 conftest.py\n\u2502   \u251c\u2500\u2500 data/\n\u2502   \u2502   \u251c\u2500\u2500 example.out\n\u2502   \u2502   \u2514\u2500\u2500 test.archive.yaml\n\u2502   \u251c\u2500\u2500 parsers/\n\u2502   \u2502   \u2514\u2500\u2500 test_parser.py\n\u2502   \u2514\u2500\u2500 schema_packages/\n\u2502       \u2514\u2500\u2500 test_schema_package.py\n\u2514\u2500\u2500 ... (other files)\n</code></pre></p> <p>You can read more about plugins in the NOMAD documentation page, see How to get started with plugins. The entry point for a parser plugin is defined in <code>src/nomad_parser_pyscf/parsers/__init__.py</code> file.</p>"},{"location":"parser_plugins/#matching-parser","title":"Matching the files to a parser","text":"<p>We are going to consider an example file generated by the software PySCF (click here for download), and use it to parse data into the <code>nomad-simulations</code> schema. If you want to learn more about extending the <code>nomad-simulations</code> schema when the information is not defined, see Extending the Schema.</p> <p>In the template, go to the entry point in <code>src/nomad_parser_pyscf/parsers/__init__.py</code> and change the content to: <pre><code>from nomad.config.models.plugins import ParserEntryPoint\n\n\nclass PySCFEntryPoint(ParserEntryPoint):\n\n    def load(self):\n        from nomad_parser_pyscf.parsers.parser import PySCFParser\n\n        return PySCFParser(**self.dict())\n\n\nparser_entry_point = PySCFEntryPoint(\n    name='PySCFParser',\n    description='Parser for PySCF output written in a log text file.',\n    mainfile_name_re='.*\\.log.*',\n    mainfile_contents_re=r'PySCF version [\\d\\.]*',\n)\n</code></pre></p> Matching other mainfiles <p>In the <code>ParserEntryPoint</code> class, there are several attributes that can be defined to match a file. These can be mainfile name, a regular expression (regex) at the beginning of the mainfile, binary file headers, etc. For your specific use-case, you need to identify which is the mainfile and use it to match it to your parser. You can read more of the options in the NOMAD documentation page Reference - Configuration - ParserEntryPoint.</p> <p>Note that we deleted the configuration parameter field (as it is not relevant for the purpose of this example) and changed some naming of files, <code>src/nomad_parser_pyscf/parsers/parser.py</code> for <code>parser.py</code>, as well as slightly its content: <pre><code># all the other imports are here\n\nconfiguration = config.get_plugin_entry_point(\n    'nomad_parser_pyscf.parsers:parser_entry_point'\n)\n\n\nclass PySCFParser(MatchingParser):\n    def parse(\n        self,\n        mainfile: str,\n        archive: 'EntryArchive',\n        logger: 'BoundLogger',\n        child_archives: dict[str, 'EntryArchive'] = None,\n    ) -&gt; None:\n        print('Hello world!')\n</code></pre></p> <p>Note that we have also changed the class imported in <code>tests/parsers/test_parser.py</code> from <code>NewParser</code> to <code>PySCFParser</code>. Finally, as we are going to use the <code>nomad-simulations</code> package, we need to add it into our dependencies in <code>pyproject.toml</code>: <pre><code>dependencies = [\n    \"nomad-lab&gt;=1.3.0\",\n    \"nomad-simulations&gt;=0.0.3\",\n]\n</code></pre></p> <p>In order to test the parser, we can install parser plugin in editable mode (with the flag <code>-e</code>): <pre><code>uv pip install -e '.[dev]' --index-url https://gitlab.mpcdf.mpg.de/api/v4/projects/2187/packages/pypi/simple\n</code></pre></p> Installing nomad-lab <p>Until we have an official pypi NOMAD release with the plugins functionality make sure to include NOMAD's internal package registry (via <code>--index-url</code> in the above command). Alternatively, you can add the following lines to the <code>pyproject.toml</code>: <pre><code>[tool.uv]\nindex-url = \"https://gitlab.mpcdf.mpg.de/api/v4/projects/2187/packages/pypi/simple\"\n</code></pre> And install the package with: <pre><code>uv pip install -e '.[dev]'\n</code></pre></p> <p>With these changes, you can parse the <code>glycine.log</code> file and show the archive in the terminal (note we put the <code>glycine.log</code> file in the <code>tests/data/</code> sub-folder): <pre><code>nomad parse tests/data/glycine.log\n</code></pre></p> <p>If everything went well, you should see a message run by the <code>PySCFParser().parse()</code> function: <pre><code>Hello world!\n</code></pre></p> <p>In Python (in a module, Jupyter notebook, or in the interactive terminal), you can test the parsing by importing <code>PySCFParser</code> and specifying the path to the file. Note we also need to instantiate an empty <code>EntryArchive</code> in order to pass it as an input of the <code>parse()</code> function: <pre><code>from nomad.datamodel import EntryArchive\nfrom nomad_parser_pyscf.parsers.parser import PySCFParser\n\n\narchive = EntryArchive()\n\nPySCFParser().parse(mainfile='&lt;path-to-mainfile&gt;/tests/data/glycine.log', archive=archive, logger=None)\n\n# Other operations / analyses here\n</code></pre></p>"},{"location":"parser_plugins/#mapping-to-nomad-simulations","title":"Mapping into <code>nomad-simulations</code>","text":"<p>Now that you know the basics of instantiating and populating the <code>nomad-simulations</code> schema (see Assignments in the NOMAD-Simulations) and the basics of setting up a parser, let's combine both concepts and populate the <code>nomad-simulations</code> schema from the output mainfile. The implementation of this plugin will allow you to manage data in a controlled way. You can further use it for analysis tools or include these functionalities in your research workflows. You can read more details in the NOMAD documentation page Plugins - How to write a parser. </p> <p>Depending on the format of the mainfile, extracting data will be different and you will need to implement the parsing slightly different. You might also need to manipulate the data in order to adapt to the definitions of <code>nomad-simulations</code> (shapes, types, etc.):</p> <ul> <li>Unstructured text \u2013 You need to specify the regular expression (regex) to match the text in the file in order to use it in the <code>parser.py</code> module. This is the case of our example, so you can read below how to implement it.</li> <li>Structured formats (HDF5, JSON, XML) \u2013 You can use Python libraries to extract the data (e.g., <code>h5py</code> for HDF5 files) and map it into the <code>nomad-simulations</code> schema. In the specific case of XML, you can use the <code>XMLParser</code>.</li> </ul> <p>In our example, we have an unstructured text file, <code>glycine.log</code>. For simplicity, we will start with the <code>Program</code> information: <code>name</code> and <code>version</code>. For unstructure text, we can use the NOMAD implementation class, <code>TextParser</code>. We need to:</p> <ol> <li>Define a class inheriting from <code>TextParser</code>.</li> <li>Overwrite its method <code>init_quantities()</code> and define <code>self._quantities</code> as a list of <code>nomad.parsing.file_parser.Quantity</code>. Note this is a different class than the one used for defining a schema, and we will refer to it as <code>ParsedQuantity</code> from now on.</li> <li><code>ParsedQuantity()</code> has a <code>key: value</code> structure and can take several arguments, being the most important ones:<ul> <li>First argument is the <code>key</code> string to identify the parsed quantity.</li> <li>Second argument is the regex associated with that <code>key</code> to match the text.</li> <li><code>repeats</code> is a boolean used to repeat multiple times. If <code>repeats=True</code> and the regex matches, it returns a list. Otherwise it returns nothing or a singular value.</li> </ul> </li> <li>Instantiate the class of point 1 in the <code>parse()</code> function and define the path to its mainfile.</li> </ol> <p>We can implement these steps in <code>src/nomad_parser_pyscf/parsers/parser.py</code>. First, we add these lines before <code>PySCFParser(MatchingParser)</code>: <pre><code>from typing import (\n    TYPE_CHECKING,\n)\n\nif TYPE_CHECKING:\n    from nomad.datamodel.datamodel import (\n        EntryArchive,\n    )\n    from structlog.stdlib import (\n        BoundLogger,\n    )\n\nfrom nomad.config import config\nfrom nomad.parsing.parser import MatchingParser\nfrom nomad.parsing.file_parser import Quantity as ParsedQuantity, TextParser\n\n\nconfiguration = config.get_plugin_entry_point(\n    'nomad_parser_pyscf.parsers:parser_entry_point'\n)\n\n\nclass LogParser(TextParser):\n    def init_quantities(self):\n        self._quantities = [\n            ParsedQuantity(\n                'program_version', r'PySCF *version *([\\d\\.]+)', repeats=False\n            )\n        ]\n</code></pre></p> <p>Note we defined <code>LogParser()</code> and its <code>self._quantities</code> to match the <code>version</code> of the PySCF run. The <code>name</code> will be anyways set up to be <code>'PySCF'</code> during parsing.</p> <p>If the regex matches, then this should return the value appearing after the string <code>'PySCF version'</code>, i.e., <code>'2.2.1'</code>. We can test this by: <pre><code>class PySCFParser(MatchingParser):\n    def parse(\n        self,\n        mainfile: str,\n        archive: 'EntryArchive',\n        logger: 'BoundLogger',\n        child_archives: dict[str, 'EntryArchive'] = None,\n    ) -&gt; None:\n        log_parser = LogParser(mainfile=mainfile, logger=logger)\n        print(log_parser.get('program_version'))\n</code></pre></p> <p>If we run now <code>nomad parse tests/data/glycine.log</code> we obtain: <pre><code>2.2.1\n</code></pre></p> <p>Now, we can instantiate <code>Simulation</code> and <code>Program</code> sections, and add them to the <code>archive</code>. This can be done by: <pre><code># other imports here\nfrom nomad_simulations.schema_packages.general import Simulation, Program\n\n# `configuration` and `LogParser` defined here\n\n\nclass PySCFParser(MatchingParser):\n    def parse(\n        self,\n        mainfile: str,\n        archive: 'EntryArchive',\n        logger: 'BoundLogger',\n        child_archives: dict[str, 'EntryArchive'] = None,\n    ) -&gt; None:\n\n        log_parser = LogParser(mainfile=mainfile, logger=logger)\n\n        simulation = Simulation()\n        program = Program(\n            name='PySCF', version=log_parser.get('program_version')\n        )\n        simulation.program = program\n\n        # Add the `Simulation` activity to the `archive`\n        archive.data = simulation\n</code></pre></p> <p>Now, this populated schema can be output adding a <code>print</code> statement with the path to the section or quantity, after <code>archive.data</code> is assigned in the parser: <pre><code>        print(archive.data.program.name, archive.data.program.version)\n</code></pre> Or we can use the flag <code>--show-archive</code> when running the <code>nomad parse</code> command to print the archive in the terminal: <pre><code>nomad parse --show-archive tests/data/glycine.log\n</code></pre> And we obtain: <pre><code>{\n  \"data\": {\n    \"m_def\": \"nomad_simulations.schema_packages.general.Simulation\",\n    \"program\": {\n      \"name\": \"PySCF\",\n      \"version\": \"2.2.1\"\n    }\n  },\n  # other metadata here\n}\n</code></pre></p>"}]}